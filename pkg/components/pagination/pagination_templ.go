// Code generated by templ - DO NOT EDIT.

// templ: version: v0.2.747
package pagination

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"fmt"
	"github.com/chrisbward/templstrap.io/pkg/base"
	"github.com/chrisbward/templstrap.io/pkg/components/pagination/paginationitem"
	"strings"
)

const RootClassName = "pagination"

type AlignmentType string

const JustifyContentCenterAlignmentType AlignmentType = "justify-content-center"
const JustifyContentEndAlignmentType AlignmentType = "justify-content-end"

type PageConditions struct {
	CurrentPage                  int
	TotalPageCount               int
	PageIsDisabledUnderCondition *func(pageNumber int) bool
}

func (pc *PageConditions) IsCurrentPage(pageNumber int) bool {
	return pc.CurrentPage == pageNumber
}
func (pc *PageConditions) IsPageDisabled(pageNumber int) bool {
	if pc.PageIsDisabledUnderCondition == nil {
		return false
	}
	return (*pc.PageIsDisabledUnderCondition)(pageNumber)
}

func (pc *PageConditions) HasNextPage() bool {
	return pc.CurrentPage < pc.TotalPageCount
}

type PaginationButtonOptions struct {
	ShouldPersist bool
	IsDisabled    bool
	Content       string
}

type PaginationItemsProps struct {
	base.ElementProps
	// HTMXAttributes *base.HTMXProps
}

type PaginationContolsOptions struct {
	IsPreviousButton      bool
	IsNextButton          bool
	PreviousButtonOptions PaginationButtonOptions
	NextButtonOptions     PaginationButtonOptions
}

func (pco PaginationContolsOptions) GetPreviousButtonContent() string {

	if pco.PreviousButtonOptions.Content == "" {
		return "Previous"
	}
	return pco.PreviousButtonOptions.Content
}

func (pco PaginationContolsOptions) GetNextButtonContent() string {

	if pco.NextButtonOptions.Content == "" {
		return "Next"
	}
	return pco.NextButtonOptions.Content
}

type PaginationProps struct {
	base.ElementProps
	RootURL                  string
	RootResultsURL           string
	Alignment                AlignmentType
	PageConditions           PageConditions
	PaginationContolsOptions PaginationContolsOptions
	PaginationItemsProps     PaginationItemsProps
	BuildURLCallback         *func(desiredPage int) string
}

type PaginationPageReferenceType int

var (
	PreviousPagePaginationPageReferenceType = -1
	NextPagePaginationPageReferenceType     = 0
)

// ReconstructURL - useful for rebuilding querystrings via model
func (pp *PaginationProps) ReconstructURL(desiredPageNumber int) string {
	if desiredPageNumber == PreviousPagePaginationPageReferenceType {
		desiredPageNumber = pp.PageConditions.CurrentPage - 1
	}
	if desiredPageNumber == NextPagePaginationPageReferenceType {
		desiredPageNumber = pp.PageConditions.CurrentPage + 1
	}
	if pp.BuildURLCallback == nil {
		return fmt.Sprintf("%s?pagination=true&page=%d", pp.RootURL, desiredPageNumber)
	}
	return (*pp.BuildURLCallback)(desiredPageNumber)
}

func (pc *PaginationProps) IsPreviousButtonDisabled() bool {
	return pc.PageConditions.CurrentPage == 1 || pc.PaginationContolsOptions.PreviousButtonOptions.IsDisabled
}

func (pp PaginationProps) BuildClassName() (classes string) {
	classNames := []string{RootClassName}

	if pp.AdditionalClasses != nil {
		classNames = append(classNames, pp.AdditionalClasses...)
	}

	classes = strings.Join(classNames, " ")

	return
}

func (pp PaginationProps) GetElementPropsForItem(pageNumber int) base.ElementProps {

	elementProps := pp.PaginationItemsProps.ElementProps

	if pageNumber == PreviousPagePaginationPageReferenceType {
		elementProps.IsDisabled = pp.IsPreviousButtonDisabled()
	} else {
		elementProps.IsDisabled = pp.PageConditions.IsPageDisabled(pageNumber)
	}

	newExtraAttributes := make(map[string]any, len(elementProps.ExtraAttributes))
	for k, v := range elementProps.ExtraAttributes {
		newExtraAttributes[k] = v
	}
	newExtraAttributes["hx-get"] = fmt.Sprintf("%s%s", pp.RootResultsURL, pp.ReconstructURL(pageNumber))

	return base.ElementProps{
		ExtraAttributes: newExtraAttributes,
		HTMX:            elementProps.HTMX,
		IsDisabled:      elementProps.IsDisabled,
	}
}

func Show(props PaginationProps) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString("<nav aria-label=\"Pagination\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 = []any{props.BuildClassName()}
		templ_7745c5c3_Err = templ.RenderCSSItems(ctx, templ_7745c5c3_Buffer, templ_7745c5c3_Var2...)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString("<ul class=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var3 string
		templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(templ.CSSClasses(templ_7745c5c3_Var2).String())
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `pkg/components/pagination/pagination.templ`, Line: 1, Col: 0}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString("\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		if props.PaginationContolsOptions.PreviousButtonOptions.ShouldPersist {
			templ_7745c5c3_Err = paginationitem.Show(paginationitem.PaginationItemProps{
				ElementProps: props.GetElementPropsForItem(PreviousPagePaginationPageReferenceType),
				// ElementProps: base.ElementProps{
				// 	IsDisabled: props.IsPreviousButtonDisabled(),
				// },
				IsPreviousButton: true,
				IsActive:         false,
				AriaLabel:        "Visit the previous page",
				Content:          props.PaginationContolsOptions.GetPreviousButtonContent(),
				BuiltURL:         props.ReconstructURL(PreviousPagePaginationPageReferenceType),
			}).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		for iLoopA := 1; iLoopA < props.PageConditions.TotalPageCount+1; iLoopA++ {
			templ_7745c5c3_Err = paginationitem.Show(paginationitem.PaginationItemProps{
				ElementProps: props.GetElementPropsForItem(iLoopA),
				IsActive:     props.PageConditions.IsCurrentPage(iLoopA),
				AriaLabel:    fmt.Sprintf("Go to page %d", iLoopA),
				Content:      fmt.Sprintf("%d", iLoopA),
				BuiltURL:     props.ReconstructURL(iLoopA),
			}).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		if props.PageConditions.HasNextPage() {
			templ_7745c5c3_Err = paginationitem.Show(paginationitem.PaginationItemProps{
				ElementProps: props.GetElementPropsForItem(NextPagePaginationPageReferenceType),
				IsNextButton: true,
				IsActive:     false,
				AriaLabel:    "Visit the next page",
				Content:      props.PaginationContolsOptions.GetNextButtonContent(),
				BuiltURL:     props.ReconstructURL(NextPagePaginationPageReferenceType),
			}).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString("</ul></nav>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return templ_7745c5c3_Err
	})
}
